/* Generated by Together */
package com.greenmark.utils;

import com.greenmark.common.core.Labels;
import lombok.extern.slf4j.Slf4j;

import java.text.*;
import java.util.*;

/** The UTCalendar class is used by all date functions of the software.  It combines the java.util.Date
 *  object and the java Calendar object.   This class provides many convenience functions to initialize,
 *  format and display dates used by the software system.
 */
@Slf4j
public class UTCalendar
{

	public static final long AVG_NUM_MILLISECONDS_IN_DAY = 86400000;

	/** The java Calendar object used for this object's date calculations.  */
	protected Calendar calendar;

	/** The java.util.Date object that is set for the date this UTCalendar object represents. */
	protected java.util.Date javaDate;

	protected int year_i;
	protected int month_i;
	protected int day_i;

	/** A static definition that a programmer can set to 1 and rebuild the code in order to see Calendar information on the
	 *  application server's standard output.  */
	protected static int DEBUG_CALENDARS = 0;

	/** An array of full month names that is used to transform month names to month digits.  */
	public static final String monthNames[] =
		{
		"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};

	/** An array of month digits, with leading zeros (01-12), that is used to transform month names to month digits.  */
	public static final String monthInts[] =
		{"01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"};

	private void parseJavaDate ()
	{
		// Init Default values if exception formatting date
		year_i = 1970;
		month_i = 1;
		day_i = 1;

		// Format the internal javaDate to parse into int values, which will be applied to the calendar later.
		SimpleDateFormat formatter = new SimpleDateFormat( "yyyyMMdd" );
		String formattedDate = formatter.format( javaDate );

		try
		{
			year_i = Integer.parseInt( formattedDate.substring(0, 4));
			month_i = Integer.parseInt( formattedDate.substring(4, 6));
			day_i = Integer.parseInt( formattedDate.substring(6, formattedDate.length() ));
		}
		catch ( NumberFormatException nfe )
		{
			System.out.println( "============= ERROR IN UTCalendar parseJavaDate()!     Exception Message:  [" + nfe.getMessage() + "]" );
		}
	}


	/**
	 * The default constructor creates an UTCalendar object.
	 */
	public UTCalendar()
	{
	}

	/**
	 * This constructor creates an UTCalendar object and sets its date to be the date of the oldCal, another
	 * UTCalendar object.
	 *
	 * @param oldCal The UTCalendar object that contains the date we will use to construct this object.
	 * @return Constructor method returns this object.
	 */
	public UTCalendar( UTCalendar oldCal )
	{
		String thismethod = "UTCalendar() UTCalendar";
//		trace.in( thismethod );

		try
		{
			javaDate = oldCal.getJavaDate();

	      //  Store the int vals that represent the javaDate
//	      parseJavaDate();

			createCalendar();
			calendar.setTime(javaDate);

			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
//				System.out.println("*************  In UTCalendar Constructor UTCalendar trace  *************");
				displayDateInfo();
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar Constructor(UTCalendar)!     Exception Message:  [" + ex.getMessage() + "]" );
		}

//		trace.out( thismethod );
	}


	/**
	 * This constructor creates an UTCalendar object and sets its date to be the date contained in the sqlDateString.
	 * If this sqlDateString is null, will construct a default date of 1/1/9999.  This is used for empty date objects,
	 * which will display nothing if their date is in the year 9999.
	 *
	 * @param sqlDateString A string for the input date that is in SQL format:  YYYY-MM-DD.
	 * @return Constructor method returns this object.
	 */
	public UTCalendar( String sqlDateString ) throws Exception
	{
		String thismethod = "UTCalendar() sqlDateString";
//		trace.in( thismethod );
//		 log.debug( "INPUT:  sqlDateString: " + sqlDateString );

		try
		{
			if ( (sqlDateString == null) || (sqlDateString.equals("null"))
			  || (sqlDateString.equals("")) || (sqlDateString.equals(" "))  )
			{
				setCalendar("January", "01", "9999" );
			}
			else
			{
				createCalendar();

				int year = Integer.parseInt(sqlDateString.substring(0, 4));


				if ( ( year < 1900 ) || ( year > 3000 ) )
					 throw new Exception ("Invalid Year");


				//  PARSE THE MONTH
				int lastDelimPos = 4;
				int nextDelimPos = sqlDateString.indexOf( "-", lastDelimPos + 1 );
				int month = Integer.parseInt(sqlDateString.substring(lastDelimPos+1, nextDelimPos));

				if ( ( month < 1 ) || ( month > 12 ) )
				    throw new Exception ("Invalid Month");

				//  PARSE THE DAY
				lastDelimPos = nextDelimPos;
				nextDelimPos = sqlDateString.indexOf( " ", lastDelimPos + 1 );

	         if ( nextDelimPos == -1 )
				   nextDelimPos = sqlDateString.length();

				int day = Integer.parseInt(sqlDateString.substring(lastDelimPos+1, nextDelimPos));

				if ( ( day < 1 ) || ( day > 31 ) )
				    throw new Exception ("Invalid Day");

//				int year = Integer.parseInt(sqlDateString.substring(0, 4));
//				int month = Integer.parseInt(sqlDateString.substring(5, 7));
//				int day = Integer.parseInt(sqlDateString.substring(8, 10));

				int hour = 12;
				int minute = 01;
				int second = 01;
				calendar.set(year, month - 1, day, hour, minute, second);
				javaDate = calendar.getTime();

				if (UTCalendar.DEBUG_CALENDARS == 1)
				{
//					System.out.println("*************  In UTCalendarTime Constructor sqlDateString trace  *************");
					displayDateInfo();
				}
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar Constructor(sqlDateString)!     Exception Message:  [" + ex.getMessage() + "]" );
			throw ex;
		}

//		trace.out( thismethod );
	}

	/**
	 * This constructor creates an UTCalendar object and sets its date to be the date specified by the input
	 * java.util.Date object.
	 *
	 * @param inDate A java Date object that is used for the input date.
	 * @return Constructor method returns this object.
	 */
	public UTCalendar( java.util.Date inDate )
	{
		String thismethod = "UTCalendar() java.util.Date";
//		trace.in( thismethod );

		try
		{
			createCalendar();
			SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
			String strDate = formatter.format(inDate);

			int year = Integer.parseInt(strDate.substring(0, 4));
			int month = Integer.parseInt(strDate.substring(5, 7));
			int day = Integer.parseInt(strDate.substring(8, 10));
			int hour = 12;
			int minute = 01;
			int second = 01;
			calendar.set(year, month - 1, day, hour, minute, second);
			javaDate = calendar.getTime();

			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
				System.out.println("************* In UTCalendar Constructor java.util.Date Trace *************");
				displayDateInfo();
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar Constructor(inDate)!     Exception Message:  [" + ex.getMessage() + "]" );
		}

//		trace.out( thismethod );
	}

//	/**
//	 * This constructor creates an UTCalendar object and sets its date to be the date contained in the dtnDatetime.
//	 * If this dtnDatetime is null, will construct a default date of 1/1/9999.  This is used for empty date objects,
//	 * which will display nothing if their date is in the year 9999.
//	 *
//	 * @param dtnDatetime A string for the input date that is in SQL format:  YYYY-MM-DD. or YYYY-M-D
//	 * @param trace Used for production environment debugging and performance monitoring.
//	 * @return Constructor method returns this object.
//	 */
//	public UTCalendar( String dtnDatetime)
//	{
//		String thismethod = "UTCalendar() sqlDateString";
//
//		log.debug( "INPUT:  dtnDatetime: " + dtnDatetime );
//
//		try
//		{
//			if ( (dtnDatetime == null) || (dtnDatetime.equals("null")))
//			{
//				setCalendar("January", "01", "9999" );
//			}
//			else
//			{
//				createCalendar();
//
//
//				int year = Integer.parseInt(dtnDatetime.substring(0, 4));
//
//				//  PARSE THE MONTH
//				int lastDelimPos = 4;
//				int nextDelimPos = dtnDatetime.indexOf( "-", lastDelimPos + 1 );
//				int month = Integer.parseInt(dtnDatetime.substring(lastDelimPos+1, nextDelimPos));
//
//				//  PARSE THE DAY
//				lastDelimPos = nextDelimPos;
//				nextDelimPos = dtnDatetime.indexOf( " ", lastDelimPos + 1 );
//				int day = Integer.parseInt(dtnDatetime.substring(lastDelimPos+1, nextDelimPos));
//
///** OLD STUFF , BETTER WAY ABOVE
//				int year = Integer.parseInt(dtnDatetime.substring(0, 4));
//				int monthDash = dtnDatetime.indexOf( "-", 5 );
//				int month = Integer.parseInt(dtnDatetime.substring(5, monthDash));
//
//				int dayDash = dtnDatetime.indexOf( " ", monthDash + 1 );
//				int day = Integer.parseInt(dtnDatetime.substring( monthDash + 1, dayDash));
//**/
//
//				int hour = 12;
//				int minute = 01;
//				int second = 01;
//				calendar.set(year, month - 1, day, hour, minute, second);
//				javaDate = calendar.getTime();
//
//				if (UTCalendar.DEBUG_CALENDARS == 1)
//				{
////					System.out.println("*************  In UTCalendarTime Constructor sqlDateString trace  *************");
//					displayDateInfo();
//				}
//			}
//		}
//		catch( Exception ex )
//		{
//			System.out.println( "============= ERROR IN UTCalendar Constructor(dtnDatetime, trace)!     Exception Message:  [" + ex.getMessage() + "]" );
//		}
//
//	}


	/**
	 * This constructor creates an UTCalendar object and sets its date to be the date specified by the input
	 * monthName, day and year.
	 *
	 * @param monthName A string for the input month name.  This is the full Gregorian name:  January, February, etc.
	 * @param day A string for the input day of the month.
	 * @param year A string for the input year.
	 * @param trace Used for production environment debugging and performance monitoring.
	 * @return Constructor method returns this object.
	 */
	public UTCalendar( String monthName, String day, String year )
	{
		String thismethod = "UTCalendar() monthName day year";
//		trace.in( thismethod );
//		 log.debug( "INPUT:  monthName: " + monthName );
//		 log.debug( "INPUT:  day: " + day );
//		 log.debug( "INPUT:  year: " + year );

		try
		{
			setCalendar(monthName, day, year);
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar Constructor(month,day,year)!     Exception Message:  [" + ex.getMessage() + "]" );
		}

//		trace.out( thismethod );
	}

	/**
	 * The setCalendar method sets an InItalyObject to be the date specified by the input
	 * monthName, day and year.
	 *
	 * @param monthName A string for the input month name.  This is the full Gregorian name:  January, February, etc.
	 * @return None.
	 */
	public final void setCalendar( String monthName, String dayStr, String yearStr )
	{
		String thismethod = "UTCalendar_setCalendar monthName day yearStr";
//		trace.in( thismethod );
//		 log.debug( "INPUT:  monthName: " + monthName );
//		 log.debug( "INPUT:  day: " + dayStr );
//		 log.debug( "INPUT:  year: " + yearStr );

		try
		{
			//  Check for null values and set defaults if found.  Setup null date if all in values blank.
			if ( (monthName == null) || (monthName.equals("null")) || (monthName.equals("")))
			{
				monthName = "January";
				if ( (dayStr == null) || (dayStr.equals("null")) || (dayStr.equals("")))
				{
					dayStr = "01";
					if ( (yearStr == null) || (yearStr.equals("null")) || (yearStr.equals("")))
					{
						yearStr = "9999";
					}
				}
			}

			//  First, transform the month name into the digit from 1-12 that represents the month.
			String monthInt = "";
			int index;
			for (index = 0; index < 12; index++)
			{
				if (monthName.equals(monthNames[index]) == true)
				{
					monthInt = monthInts[index];
					break;
				}
			}
			if (index == 12)
			{ // Could not find month name, must've passed in the month digit.
				monthInt = monthName;
			}

			createCalendar();
			int year = Integer.parseInt(yearStr);
			int month = Integer.parseInt(monthInt) - 1;
			int day = Integer.parseInt(dayStr);
			int hour = 12;
			int minute = 01;
			int second = 01;
			calendar.set(year, month, day, hour, minute, second);
			javaDate = calendar.getTime();

			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
				System.out.println("*************  In UTCalendar Constructor monthName day year trace  *************");
				System.out.println("monthName: " + monthName);
				System.out.println("monthInt: " + monthInt);
				System.out.println("day: " + dayStr);
				System.out.println("year: " + yearStr);
				displayDateInfo();
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar.setCalendar(month,day,year)!     Exception Message:  [" + ex.getMessage() + "]" );
		}

//		trace.out( thismethod );
	}

	/**
	 * The createCalendar method creates the internal java Calendar object that is used
	 * for calendar operations.
	 *
	 * @return None.
	 */
	public final void createCalendar( )
	{
		String thismethod = "UTCalendar_incrementDate numDays";

		try
		{
			String[] ids;
			String exceptionString = "";

			String localTimeZone = UTPropertyManager.getProperty("local_time_zone");
			int timeZoneI = -6;  // Default to -6 for CST

			if ( localTimeZone.equals("EST") )
			{
				timeZoneI = -5;
			}
			if ( localTimeZone.equals("MST") )
			{
				timeZoneI = -7;
			}
			if ( localTimeZone.equals("PST") )
			{
				timeZoneI = -8;
			}

			// get the supported ids for Time Zone
			ids = TimeZone.getAvailableIDs( timeZoneI * 60 * 60 * 1000);
			if (ids.length == 0)
         {
				exceptionString = "Error:   Cannot create Calendar for Date";
            System.out.println( exceptionString );
         }

			// create a Pacific Standard Time time zone
			SimpleTimeZone cdt = new SimpleTimeZone( timeZoneI * 60 * 60 * 1000, ids[0]);

			// set up rules for daylight savings time
			cdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
			cdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);

			// create a GregorianCalendar with the Pacific Daylight time zone
			// and the current date and time
			calendar = new GregorianCalendar(cdt);
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar.createCalendar()!     Exception Message:  [" + ex.getMessage() + "]" );
		}
	}

	/**
	 * The incrementDate method increments the date that this object represents the
	 * input numDays to create a new date.
	 *
	 * @param numDays The number of days used to increment the calendar date.
	 * @return None.
	 */
	public final void incrementDate( int numDays )
	{
		String thismethod = "UTCalendar_incrementDate numDays";
//		trace.in( thismethod );
//		 log.debug( "INPUT:  numDays: " + Integer.toString( numDays ) );

		try
		{
			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
				displayDateInfo();
			}

			//get the milliseconds
			long mils = javaDate.getTime();

			//compute the millseconds in minutes
			long total = Labels.DAY * numDays;

			//add and create new date
			long newMils = mils + total;
			javaDate = new Date(newMils);

			//set the calendar
			calendar.setTime( javaDate );

			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
				System.out.println("*************  In UTCalendar_incrementDate numDays trace  *************");
				System.out.println("numDays: " + Integer.toString(numDays));
				displayDateInfo();
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar.incrementDate(numDays)!     Exception Message:  [" + ex.getMessage() + "]" );
		}

//		trace.out( thismethod );
	}

	/**
	 * The decrementDate method decrements the date that this object represents the
	 * input numDays to create a new date.
	 *
	 * @param numDays The number of days used to decrement the calendar date.
	 * @return None.
	 */
	public final void decrementDate( int numDays )
	{
   	try
		{
			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
				displayDateInfo();
			}

			//get the milliseconds
			long mils = javaDate.getTime();

			//compute the millseconds in minutes
			long total = Labels.DAY * numDays;

			//subtract and create new date
			long newMils = mils - total;
			javaDate = new Date(newMils);

			//set the calendar
			calendar.setTime( javaDate );

			if (UTCalendar.DEBUG_CALENDARS == 1)
			{
				System.out.println("*************  In UTCalendar_decrementDate numDays trace  *************");
				System.out.println("numDays: " + Integer.toString(numDays));
				displayDateInfo();
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar.decrementDate(numDays)!     Exception Message:  [" + ex.getMessage() + "]" );
		}

//		trace.out( thismethod );
	}

	/**
	 * The displayDateInfo method is a debug utility method to send alot of this object's
	 * date information to the standard output, NOT to a webpage.
	 *
	 * @return None.
	 */
	public final void displayDateInfo( )
	{
		String thismethod = "UTCalendar_displayDateInfo";
//		trace.in( thismethod );

		// print out a bunch of interesting things
		System.out.println( "ERA: " + calendar.get( Calendar.ERA ) );
		System.out.println( "YEAR: " + calendar.get( Calendar.YEAR ) );
		System.out.println( "MONTH: " + calendar.get( Calendar.MONTH ) );
		System.out.println( "WEEK_OF_YEAR: " + calendar.get( Calendar.WEEK_OF_YEAR ) );
		System.out.println( "WEEK_OF_MONTH: " + calendar.get( Calendar.WEEK_OF_MONTH ) );
		System.out.println( "DATE: " + calendar.get( Calendar.DATE ) );
		System.out.println( "DAY_OF_MONTH: " + calendar.get( Calendar.DAY_OF_MONTH ) );
		System.out.println( "DAY_OF_YEAR: " + calendar.get( Calendar.DAY_OF_YEAR ) );
		System.out.println( "DAY_OF_WEEK: " + calendar.get( Calendar.DAY_OF_WEEK ) );
		System.out.println( "DAY_OF_WEEK_IN_MONTH: "
								  + calendar.get( Calendar.DAY_OF_WEEK_IN_MONTH ) );
		System.out.println( "AM_PM: " + calendar.get( Calendar.AM_PM ) );
		System.out.println( "HOUR: " + calendar.get( Calendar.HOUR ) );
		System.out.println( "HOUR_OF_DAY: " + calendar.get( Calendar.HOUR_OF_DAY ) );
		System.out.println( "MINUTE: " + calendar.get( Calendar.MINUTE ) );
		System.out.println( "SECOND: " + calendar.get( Calendar.SECOND ) );
		System.out.println( "MILLISECOND: " + calendar.get( Calendar.MILLISECOND ) );
		System.out.println( "ZONE_OFFSET: "
								  + ( calendar.get( Calendar.ZONE_OFFSET ) / ( 60 * 60 * 1000 ) ) );
		System.out.println( "DST_OFFSET: "
								  + ( calendar.get( Calendar.DST_OFFSET ) / ( 60 * 60 * 1000 ) ) );

//		trace.out( thismethod );
	}

	/** Returns the day of the year (1-366) for the date this UTCalendar object represents.  */
	public final int getDayOfYear()
	{
		return calendar.get( Calendar.DAY_OF_YEAR );
	}

	public final int getDayOfWeek()
	{
		return calendar.get( Calendar.DAY_OF_WEEK );
	}

	/** Returns the year (YYYY) for the date this UTCalendar object represents.  */
	public final int getYear()
	{
		return calendar.get( Calendar.YEAR );
	}

	/** Returns the month (01-12) for the date this UTCalendar object represents.  */
	public final int getMonth()
	{
		int returnInt = -1;
		if( isNull() )
		{
			return 0;
		}
		else
		{
			returnInt = calendar.get( Calendar.MONTH ) + 1; // Month origin is zero.
			return returnInt;
		}
	}

	/** Returns the day of the month (01-31) for the date this UTCalendar object represents.  */
	public final int getDay()
	{
		if( isNull() )
		{
			return 0;
		}
		else
		{
			return calendar.get( Calendar.DAY_OF_MONTH );
		}
	}

	public boolean isWeekendDay ()
	{
		if ( ( calendar.get( Calendar.DAY_OF_WEEK ) == Calendar.SUNDAY ) ||
			  ( calendar.get( Calendar.DAY_OF_WEEK ) == Calendar.SATURDAY ) )
			return true;
		else
			return false;
	}


   public final boolean isSunday ()
   {
      if ( calendar.get( Calendar.DAY_OF_WEEK ) == Calendar.SUNDAY )
         return true;
      else
         return false;
   }


	/** Not used for UTCalendar - Use for UTCalendarTime subclass only.
	 * Returns the Hour of the Day (01-24) for the date this UTCalendar object represents.  */
	public final int getHour()
	{
		return calendar.get( Calendar.HOUR_OF_DAY );
	}

	/** Not used for UTCalendar - Use for UTCalendarTime subclass only.
	 * Returns the minute of the hour (01-60) for the date this UTCalendar object represents.  */
	public final int getMinute()
	{
		return calendar.get( Calendar.MINUTE );
	}

	/** Not used for UTCalendar - Use for UTCalendarTime subclass only.
	 * Returns the second of the minute (01-60) for the date this UTCalendar object represents.  */
	public final int getSecond()
	{
		return calendar.get( Calendar.SECOND );
	}

	/** Not used for UTCalendar - Use for UTCalendarTime subclass only.
	 * Returns the millisecond of the second (001-999) for the date this UTCalendar object represents.  */
	public final int getMillisecond()
	{
		return calendar.get( Calendar.MILLISECOND );
	}

	/** Returns a java.util.Date object that is set for the date this UTCalendar object represents.  */
	public final java.util.Date getJavaDate()
	{
		return javaDate;
	}

	/** Returns a java Calendar object that is set for the date this UTCalendar object represents.  */
	public final Calendar getCalendar()
	{
		return calendar;
	}

	/** Formats an UTCalendar object date for display by a webpage - If this object's year is set to 9999
	 *  This method will return the string "N/A".    */
	public final String formatDateDisplay()
	{
		if( ( calendar == null ) || ( getYear() == 9999 ) || ( getYear() == 9998 ) )
		{
			return "N/A";
		}
		else // We shouldn't have to add one to the month display.  This seems to make it all work ok....
		{
			return Integer.toString( getMonth() ) + "/" + Integer.toString( getDay() ) + "/" + Integer.toString( getYear() );
		}
	}

	public final String formatDateDisplay(String delimiter)
	{
		if( ( calendar == null ) || ( getYear() == 9999 ) || ( getYear() == 9998 ) )
		{
			return "N/A";
		}
		else // We shouldn't have to add one to the month display.  This seems to make it all work ok....
		{
			return Integer.toString( getMonth() ) + delimiter + Integer.toString( getDay() ) + delimiter + Integer.toString( getYear() );
		}
	}

	/** Formats an UTCalendarTime object date for stamping files.    */
	public String formatFileDate()
	{
		try
		{
			if (isNull())
			{
				return "NULL";
			}
			else
			{
				String monthString, dayString;
				int month = getMonth();
				int day = getDay();

				if (month < 10)
				{
					monthString = "0" + Integer.toString(getMonth());
				}
				else
				{
					monthString = Integer.toString(getMonth());
				}
				if (day < 10)
				{
					dayString = "0" + Integer.toString(getDay());
				}
				else
				{
					dayString = Integer.toString(getDay());
				}

				return Integer.toString(getYear()) + "_" + monthString + "_" + dayString;
			}
		}
		catch( Exception ex )
		{
			System.out.println( "============= ERROR IN UTCalendar.formatFileDate()!     Exception Message:  [" + ex.getMessage() + "]" );
			return "NULL";
		}
	}


	public final String formatSimpleDateDisplay()
	{
		SimpleDateFormat formatter = new SimpleDateFormat( "MM-dd-yyyy" );
		String strDate = formatter.format( javaDate );
		return strDate;
	}

	public final String formatEuroDateDisplay()
	{
		if( ( calendar == null ) || ( getYear() == 9999 ) || ( getYear() == 9998 ) )
		{
			return "N/A";
		}
		else // We shouldn't have to add one to the month display.  This seems to make it all work ok....
		{
			return Integer.toString( getDay() ) + "/" + Integer.toString( getMonth() ) + "/" + Integer.toString( getYear() );
		}
	}

	/** Formats an UTCalendar object date for use as website parameters.    */
	public String formatDateParam()
	{
		if( isNull() )
		{
			return "NULL";
		}
		else
		{
			return Integer.toString( getYear() ) + "-" +
				Integer.toString( getMonth() ) + "-" +
				Integer.toString( getDay() );
		}
	}


	/** Formats an UTCalendar object date for insertion into the database.    */
	public String formatDBDate()
	{
		if( isNull() )
		{
			return "NULL";
		}
		else
		{
			return "'" + Integer.toString( getYear() ) + "-" +
				Integer.toString( getMonth() ) + "-" +
				Integer.toString( getDay() ) +
				" 12:12:01.000'";
		}
	}

	/** Formats an UTCalendar object date for keeping track of filenames with dates in them.    */
	public String formatYearFirstDate()
	{
		if( isNull() )
		{
			return "NULL";
		}
		else
		{  // Pad month values with zero to help filenames stay sorted correctly.
			int monthVal = getMonth();
			String monthStr = "";
			if ( monthVal < 10 )
			  monthStr = "0" + Integer.toString(monthVal);
			else
				monthStr =  Integer.toString(monthVal);

	      // Pad day values with zero to help filenames stay sorted correctly.
			int dayVal = getDay();
			String dayStr = "";
			if ( dayVal < 10 )
			  dayStr = "0" + Integer.toString(dayVal);
			else
				dayStr =  Integer.toString(dayVal);

			return Integer.toString( getYear() ) + "_" + monthStr + "_" + dayStr;
		}
	}

	/** Formats an UTCalendar object date for passing dates as parameters to webpages.    */
	public String formatParameterDate()
	{
		if( isNull() )
		{
			return "NULL";
		}
		else
		{  // Pad month values with zero to help filenames stay sorted correctly.
			int monthVal = getMonth();
			String monthStr = "";
			if ( monthVal < 10 )
			  monthStr = "0" + Integer.toString(monthVal);
			else
				monthStr =  Integer.toString(monthVal);

			// Pad day values with zero to help filenames stay sorted correctly.
			int dayVal = getDay();
			String dayStr = "";
			if ( dayVal < 10 )
			  dayStr = "0" + Integer.toString(dayVal);
			else
				dayStr =  Integer.toString(dayVal);

			return Integer.toString( getYear() ) + "-" + monthStr + "-" + dayStr;
		}
	}


	public final boolean isNull()
	{
		if( ( calendar == null ) || ( getYear() == 9999 ) || ( getYear() == 9998 ) )
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	public final boolean isEqualInCalendarDate( UTCalendar inCal )
	{
		if ( ( getYear() < inCal.getYear() ) ||  ( getYear() > inCal.getYear() ) )
			return false;
		else if ( ( getMonth() < inCal.getMonth() ) || ( getMonth() > inCal.getMonth() ) ) // The years must be equal
			return false;
		else if ( ( getDay() < inCal.getDay() ) || ( getDay() > inCal.getDay() ) )
			return false;
		else
			return true;
	}

	public final boolean isBeforeInCalendarDate( UTCalendar inCal )
	{
		if( getYear() < inCal.getYear() )
			return true;
		else if ( getYear() > inCal.getYear() )
			return false;
		else if ( getMonth() < inCal.getMonth() ) // The years already must be equal
			return true;
		else if ( getMonth() > inCal.getMonth() ) // The years already must be equal
			return false;
		else if ( getDay() < inCal.getDay() )
			return true;
		else
			return false;
	}

	public final boolean isAfterInCalendarDate( UTCalendar inCal )
	{
		if( getYear() > inCal.getYear() )
			return true;
		else if ( getYear() < inCal.getYear() )
			return false;
		else if ( getMonth() > inCal.getMonth() ) // The years already must be equal
			return true;
		else if ( getMonth() < inCal.getMonth() ) // The years already must be equal
			return false;
		else if ( getDay() > inCal.getDay() )
			return true;
		else
			return false;
	}

  public static final java.util.Date fromNumdate ( int numdate )
  {
	  java.util.Date outCal = null;

	  try
	  {
		  int dayOfYear = numdate % 365;
		  Calendar calendar = new GregorianCalendar();
		  calendar.set(Calendar.DAY_OF_YEAR, dayOfYear);
		  outCal = calendar.getTime();
	  }
	  catch (Exception ex)
	  {
		  System.out.println("============= ERROR IN UTCalendar.fromNumdate()!     Exception Message:  [" + ex.getMessage() + "]");
		  return null;
	  }

	  return outCal;
}

}
